<!doctype html><html lang=zh-CN data-theme=dark><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: dark)"><meta name=generator content="Hugo 0.115.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content><meta itemprop=description content="保持简单的易用性和强大的功能。"><meta itemprop=image content="https://wtwtyyds.github.io/imgs/hugo_next_avatar.png"><meta itemprop=keywords content="Hugo,NexT,主题,简单,强大"><meta property="og:type" content="article"><meta property="og:title" content="Hugo NexT"><meta property="og:description" content="保持简单的易用性和强大的功能。"><meta property="og:image" content="/imgs/hugo_next_avatar.png"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="https://wtwtyyds.github.io/post/gee%E5%AD%A6%E4%B9%A0/"><meta property="og:site_name" content="Hugo NexT"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="NexT 主题"><meta property="article:published_time" content="0001-01-01 00:00:00 +0000 UTC"><meta property="article:modified_time" content="0001-01-01 00:00:00 +0000 UTC"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.ff5358e101ab82ec794f45d2098d2c4ffcc8f07f2a73d9524fbc39dc6612ec3f.css><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"gee%E5%AD%A6%E4%B9%A0","permalink":"https://wtwtyyds.github.io/post/gee%E5%AD%A6%E4%B9%A0/","title":"","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>- Hugo NexT</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>Hugo NexT</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>为 Hugo 打造的主题</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about.html class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-flinks"><a href=/flinks.html class=hvr-icon-pulse rel=section><i class="fa fa-thumbs-up hvr-icon"></i>站点示例</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>1</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#单元测试>单元测试：</a></li><li><a href=#gee框架的雏形>Gee框架的雏形</a><ul><li><ul><li></li></ul></li><li><a href=#注意>注意</a><ul><li></li></ul></li></ul></li><li><a href=#context与handle的变化>Context与handle的变化</a><ul><li><ul><li></li></ul></li></ul></li></ul><ul><li><ul><li><a href=#并发冲突>并发冲突</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt="NexT 主题" src=/imgs/img-lazy-loading.gif data-src=/imgs/hugo_next_avatar.png><p class=site-author-name itemprop=name>NexT 主题</p><div class=site-description itemprop=description>保持简单的易用性和强大的功能。</div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>1</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>0</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/elkan1788 title="Github → https://github.com/elkan1788" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>
Github</a></span>
<span class=links-of-social-item><a href=https://www.zhihu.com/people/lisenhui title="知乎 → https://www.zhihu.com/people/lisenhui" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-book fa-fw hvr-icon"></i>
知乎</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>
友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div><div id=siteinfo-card-widget class=sidebar-card-widget><div class=item-headline><i class="fas fa-chart-line"></i>
<span>网站资讯</span></div><div class=siteinfo><div class=siteinfo-item><div class=item-name><i class="fa-solid fa-calendar-check"></i>已运行：</div><div class=item-count id=runTimes data-publishdate=0001-01-01T00:00:00+00:00></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-user"></i>总访客数：</div><div class=item-count id=busuanzi_value_site_uv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fas fa fa-eye"></i>页面浏览：</div><div class=item-count id=busuanzi_value_site_pv><i class="fa fa-sync fa-spin"></i></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-font"></i>总字数：</div><div class=item-count id=wordsCount data-count=2991></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-mug-hot"></i>阅读约：</div><div class=item-count id=readTimes data-times=6></div></div><div class=siteinfo-item><div class=item-name><i class="fa fa-clock-rotate-left"></i>最后更新于：</div><div class=item-count id=last-push-date data-lastpushdate=0001-01-01T00:00:00+00:00></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><script type=text/javascript src=//sidecar.gitter.im/dist/sidecar.v1.js async></script>
<script type=text/javascript>((window.gitter={}).chat={}).options={room:"hugo-next/community"}</script><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=https://wtwtyyds.github.io/post/gee%E5%AD%A6%E4%B9%A0/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/imgs/hugo_next_avatar.png"><meta itemprop=name content="NexT 主题"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="NexT 主题"><meta itemprop=description content="保持简单的易用性和强大的功能。"></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content><meta itemprop=description content="Gee学习 单元测试： Go Test 单元测试简明教程 | 快速入门 | 极客兔兔 (geektutu.com) Gee框架的雏形 1. 将所有的HTTP请求转向了我们自己的处理逻辑。我们拦截了所有"></span><header class=post-header><h1 class=post-title itemprop="name headline"><a href=https://github.com/user-name/repo-name/tree/branch-name/subdirectory-name/post/Gee%e5%ad%a6%e4%b9%a0.md rel="noopener external nofollow noreferrer" target=_blank class="exturl post-edit-link" title=编辑><i class="fa fa-pen-nib"></i></a></h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text title=发表于>发表于：</span>
<time title="创建时间：0001-01-01 00:00:00 +0000 UTC" itemprop="dateCreated datePublished" datetime="0001-01-01 00:00:00 +0000 UTC">0001-01-01</time></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span>
<span>2991</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>6分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/gee%E5%AD%A6%E4%B9%A0/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h1 id=gee学习>Gee学习
<a class=header-anchor href=#gee%e5%ad%a6%e4%b9%a0></a></h1><h2 id=单元测试>单元测试：
<a class=header-anchor href=#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95></a></h2><p><a href=https://geektutu.com/post/quick-go-test.html title="Go Test 单元测试简明教程 | 快速入门 | 极客兔兔 (geektutu.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Go Test 单元测试简明教程 | 快速入门 | 极客兔兔 (geektutu.com)
<i class="fa fa-external-link-alt"></i></a></p><h2 id=gee框架的雏形>Gee框架的雏形
<a class=header-anchor href=#gee%e6%a1%86%e6%9e%b6%e7%9a%84%e9%9b%8f%e5%bd%a2></a></h2><h5 id=1>1.
<a class=header-anchor href=#1></a></h5><p>将所有的HTTP请求转向了我们自己的处理逻辑。我们拦截了所有的HTTP请求，拥有了统一的控制入口。在这里我们可以自由定义路由映射的规则，也可以统一添加一些处理逻辑，例如日志、异常处理等。</p><p>我们接下来重新组织上面的代码，搭建出整个框架的雏形。</p><p>最终的代码目录结构是这样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>gee/
</span></span><span style=display:flex><span>  |--gee.go	//实现基本的get,post+uRl.path/run运行/Sever HTTP实现
</span></span><span style=display:flex><span>  |--go.mod	//打包管理
</span></span><span style=display:flex><span>main.go
</span></span><span style=display:flex><span>go.mod
</span></span><span style=display:flex><span>实现:
</span></span><span style=display:flex><span>1.定义Engine结构体
</span></span><span style=display:flex><span>router map[string]HandlerFunc
</span></span><span style=display:flex><span>2.获取设置的get,post/path 并处理保存
</span></span><span style=display:flex><span>3.run	监听端口,
</span></span><span style=display:flex><span>http.ListenAndServe(addr, engine)	传入engine处理器
</span></span><span style=display:flex><span>并实现ServerHTTP
</span></span><span style=display:flex><span>获取请求的URL,path是否存在,
</span></span><span style=display:flex><span>存在则传入w,req处理 router的func
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-v data-lang=v><span style=display:flex><span><span style=color:#f92672>module</span> example
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#ae81ff>1.13</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>require gee v0<span style=color:#ae81ff>.0.0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>replace gee <span style=color:#f92672>=</span>&gt; .<span style=color:#f92672>/</span>gee
</span></span></code></pre></div><ul><li>在 <code>go.mod</code> 中使用 <code>replace</code> 将 gee 指向 <code>./gee</code></li></ul><blockquote><p>从 go 1.11 版本开始，引用相对路径的 package 需要使用上述方式。</p></blockquote><p>gee包需要有go.mod文件</p><p>项目Gee的go.mod需要引入gee 版本，和处理路径，</p><p>replace gee => ./gee</p><p>go: malformed module path &ldquo;gee&rdquo;: missing dot in first path element
go:
<a href=mailto:gee@v0.0.0 title=gee@v0.0.0>gee@v0.0.0
</a>: malformed module path &ldquo;gee&rdquo;: missing dot in first path element</p><h5 id=2>2.
<a class=header-anchor href=#2></a></h5><ul><li><p>将<code>路由(router)</code>独立出来，方便之后增强。</p></li><li><p>设计<code>上下文(Context)</code>，封装 Request 和 Response ，提供对 JSON、HTML 等返回类型的支持。</p></li><li><p><code>Handler</code>的参数变成成了<code>gee.Context</code>，提供了查询Query/PostForm参数的功能。</p></li><li><p><code>gee.Context</code>封装了<code>HTML/String/JSON</code>函数，能够快速构造HTTP响应。</p></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>gee/
</span></span><span style=display:flex><span>  |--context.go	//上下文实现
</span></span><span style=display:flex><span>  |--gee.go	//实现基本的get,post+uRl.path/run运行/Sever HTTP实现
</span></span><span style=display:flex><span>  |--go.mod	//打包管理
</span></span><span style=display:flex><span>  |--router.go	//将和路由相关的方法和结构提取了出来,易于功能修改
</span></span><span style=display:flex><span>main.go
</span></span><span style=display:flex><span>go.mod
</span></span><span style=display:flex><span>实现:
</span></span><span style=display:flex><span>context.go:
</span></span><span style=display:flex><span>1.type H map[string]interface{}	输出格式封装
</span></span><span style=display:flex><span>2.type Context struct {
</span></span><span style=display:flex><span>	//origin object
</span></span><span style=display:flex><span>	Write http.ResponseWriter
</span></span><span style=display:flex><span>	Req   *http.Request
</span></span><span style=display:flex><span>	//request info
</span></span><span style=display:flex><span>	Path   string
</span></span><span style=display:flex><span>	Method string
</span></span><span style=display:flex><span>	//response info
</span></span><span style=display:flex><span>	StatusCode int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>3.//gee.run 的ServeHTTP实现func参数w,r该为context
</span></span><span style=display:flex><span>func newContext(w http.ResponseWriter, req *http.Request) *Context {
</span></span><span style=display:flex><span>	return &amp;Context{
</span></span><span style=display:flex><span>		Write:  w,
</span></span><span style=display:flex><span>		Req:    req,
</span></span><span style=display:flex><span>		Path:   req.URL.Path,
</span></span><span style=display:flex><span>		Method: req.Method,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>router:
</span></span><span style=display:flex><span>1.存储,分配内存
</span></span><span style=display:flex><span>type router struct {
</span></span><span style=display:flex><span>	handlers map[string]HandlerFunc
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func newRouter() *router {
</span></span><span style=display:flex><span>	return &amp;router{handlers: make(map[string]HandlerFunc)}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>2.保存设置的路由
</span></span><span style=display:flex><span>func (r *router) addRoute(method string, pattern string, handler HandlerFunc)
</span></span><span style=display:flex><span>3.处理函数, 实现 上下文管理
</span></span><span style=display:flex><span>func (r *router) hande(c *Context)
</span></span><span style=display:flex><span>gee:
</span></span><span style=display:flex><span>1.接口管理,不实现方法
</span></span></code></pre></div><ul><li><h3 id=注意>注意
<a class=header-anchor href=#%e6%b3%a8%e6%84%8f></a></h3></li><li></li><li><blockquote><p>正确的调用顺序应该是Header().Set 然后WriteHeader() 最后是Write()</p></blockquote><p>感谢指出，在 <code>WriteHeader()</code> 后调用 <code>Header().Set</code> 是不会生效的，已经更正~</p></li></ul><h5 id=3>3.
<a class=header-anchor href=#3></a></h5><h5 id=gin-api系列实现动态路由分组七---runningpower---博客园-cnblogscomhttpswwwcnblogscomlxmhhyp13614097html><a href=https://www.cnblogs.com/lxmhhy/p/13614097.html title="【Gin-API系列】实现动态路由分组（七） - RunningPower - 博客园 (cnblogs.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>【Gin-API系列】实现动态路由分组（七） - RunningPower - 博客园 (cnblogs.com)
<i class="fa fa-external-link-alt"></i></a>
<a class=header-anchor href=#gin-api%e7%b3%bb%e5%88%97%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e8%b7%af%e7%94%b1%e5%88%86%e7%bb%84%e4%b8%83---runningpower---%e5%8d%9a%e5%ae%a2%e5%9b%ad-cnblogscomhttpswwwcnblogscomlxmhhyp13614097html></a></h5><p>以前缀树来实现路由存储，</p><h2 id=context与handle的变化>Context与handle的变化
<a class=header-anchor href=#context%e4%b8%8ehandle%e7%9a%84%e5%8f%98%e5%8c%96></a></h2><p>在 HandlerFunc 中，希望能够访问到解析的参数，因此，需要对 Context 对象增加一个属性和方法，来提供对路由参数的访问。我们将解析后的参数存储到<code>Params</code>中，通过<code>c.Param("lang")</code>的方式获取到对应的值。</p><p><strong>day3-router/gee/context.go</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Context struct {
</span></span><span style=display:flex><span>	// origin objects
</span></span><span style=display:flex><span>	Writer http.ResponseWriter
</span></span><span style=display:flex><span>	Req    *http.Request
</span></span><span style=display:flex><span>	// request info
</span></span><span style=display:flex><span>	Path   string
</span></span><span style=display:flex><span>	Method string
</span></span><span style=display:flex><span>	Params map[string]string	//新增字段
</span></span><span style=display:flex><span>	// response info
</span></span><span style=display:flex><span>	StatusCode int
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//新增方法
</span></span><span style=display:flex><span>func (c *Context) Param(key string) string {
</span></span><span style=display:flex><span>	value, _ := c.Params[key]
</span></span><span style=display:flex><span>	return value
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=4>4.
<a class=header-anchor href=#4></a></h5><p>路由分组控制：（Group）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>r := gee.New()
</span></span><span style=display:flex><span>v1 := r.Group(&#34;/v1&#34;)
</span></span><span style=display:flex><span>v1.GET(&#34;/&#34;, func(c *gee.Context) {
</span></span><span style=display:flex><span>	c.HTML(http.StatusOK, &#34;&lt;h1&gt;Hello Gee&lt;/h1&gt;&#34;)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>那么Group对象，还需要有访问<code>Router</code>的能力，为了方便，我们可以在Group中，保存一个指针，指向<code>Engine</code>，整个框架的所有资源都是由<code>Engine</code>统一协调的，那么就可以通过<code>Engine</code>间接地访问各种接口了。</p><p>group/gee/gee.go:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>RouterGroup struct {
</span></span><span style=display:flex><span>	prefix      string
</span></span><span style=display:flex><span>	middlewares []HandlerFunc // support middleware
</span></span><span style=display:flex><span>	parent      *RouterGroup  // support nesting
</span></span><span style=display:flex><span>	engine      *Engine       // all groups share a Engine instance
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func New() *Engine {
</span></span><span style=display:flex><span>	engine := &amp;Engine{router: newRouter()}
</span></span><span style=display:flex><span>	engine.RouterGroup = &amp;RouterGroup{engine: engine}
</span></span><span style=display:flex><span>	engine.groups = []*RouterGroup{engine.RouterGroup}
</span></span><span style=display:flex><span>	return engine
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>//RouterGroup实现了Engine可以调用全局所有资源
</span></span><span style=display:flex><span>// Group is defined to create a new RouterGroup
</span></span><span style=display:flex><span>// remember all groups share the same Engine instance
</span></span><span style=display:flex><span>func (group *RouterGroup) Group(prefix string) *RouterGroup {
</span></span><span style=display:flex><span>	engine := group.engine
</span></span><span style=display:flex><span>	newGroup := &amp;RouterGroup{
</span></span><span style=display:flex><span>		prefix: group.prefix + prefix,
</span></span><span style=display:flex><span>		parent: group,
</span></span><span style=display:flex><span>		engine: engine,
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	engine.groups = append(engine.groups, newGroup)
</span></span><span style=display:flex><span>	return newGroup
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们还可以进一步地抽象，将<code>Engine</code>作为最顶层的分组，也就是说<code>Engine</code>拥有<code>RouterGroup</code>所有的能力。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Engine struct {
</span></span><span style=display:flex><span>	*RouterGroup
</span></span><span style=display:flex><span>	router *router
</span></span><span style=display:flex><span>	groups []*RouterGroup // store all groups
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=geecache>geecache
<a class=header-anchor href=#geecache></a></h1><h3 id=并发冲突>并发冲突
<a class=header-anchor href=#%e5%b9%b6%e5%8f%91%e5%86%b2%e7%aa%81></a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;fmt&#34;</span>
</span></span><span style=display:flex><span>   <span style=color:#e6db74>&#34;sync&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>count</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wg</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>m</span> <span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>Mutex</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>10000</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)	<span style=color:#75715e>// 并发线程计数器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {	
</span></span><span style=display:flex><span>      <span style=color:#75715e>/*加锁的多种写法
</span></span></span><span style=display:flex><span><span style=color:#75715e>      	m.Lock()
</span></span></span><span style=display:flex><span><span style=color:#75715e>		defer m.Unlock()*/</span>
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>		
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Lock</span>()	<span style=color:#75715e>//把冲突操作枷锁
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>count</span><span style=color:#f92672>++</span> <span style=color:#75715e>// 并发修改 count 变量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>         <span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>         <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      }()
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()	<span style=color:#75715e>//等待所有线程结束释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;最终的 count 值:&#34;</span>, <span style=color:#a6e22e>count</span>)	<span style=color:#75715e>//等待线程，加锁后为10000，不进行保护会是小于10000 的变化数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h1 id=接口型函数>接口型函数
<a class=header-anchor href=#%e6%8e%a5%e5%8f%a3%e5%9e%8b%e5%87%bd%e6%95%b0></a></h1><p>没问题，我来给你解释一下接口型函数。</p><p>在Go语言中，接口是一种定义了一组方法签名的类型。接口型函数是指与接口相关联的函数。这些函数可以接收实现了接口的类型作为参数，或者返回实现了接口的类型。</p><p>接口型函数的作用在于，它们可以接受不同的类型作为参数，只要这些类型实现了相应的接口方法。这样，我们就可以通过接口实现多态性，以更灵活和通用的方式处理不同类型的数据。</p><p>让我们通过一个示例来理解接口型函数的概念。假设我们有一个接口 <code>Shape</code> 定义了一个 <code>Area</code> 方法和一个 <code>Perimeter</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Shape</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Area</span>() <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Perimeter</span>() <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们可以定义不同的类型（如 <code>Rectangle</code> 和 <code>Circle</code>）来实现这个接口。这些类型需要实现 <code>Shape</code> 接口中定义的两个方法。</p><p>接下来，我们可以编写一个接口型函数，它接收一个实现了 <code>Shape</code> 接口的类型作为参数，并调用 <code>Area</code> 和 <code>Perimeter</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>PrintShapeDetails</span>(<span style=color:#a6e22e>s</span> <span style=color:#a6e22e>Shape</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Area: %.2f\n&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Area</span>())
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;Perimeter: %.2f\n&#34;</span>, <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>Perimeter</span>())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个函数中，我们只关心 <code>Shape</code> 接口规定的方法，而不关心具体的类型。这样，我们可以像下面这样调用 <code>PrintShapeDetails</code> 函数，并传入实现了 <code>Shape</code> 接口的具体类型：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>r</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Rectangle</span>{<span style=color:#a6e22e>width</span>: <span style=color:#ae81ff>5</span>, <span style=color:#a6e22e>height</span>: <span style=color:#ae81ff>3</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>PrintShapeDetails</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Circle</span>{<span style=color:#a6e22e>radius</span>: <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>PrintShapeDetails</span>(<span style=color:#a6e22e>c</span>)
</span></span></code></pre></div><p>通过实现 <code>Shape</code> 接口，<code>Rectangle</code> 和 <code>Circle</code> 类型可以作为参数传递给 <code>PrintShapeDetails</code> 函数。无论是矩形还是圆形，函数都能通过接口方法获取面积和周长，而无需关心具体的类型。</p><p>接口型函数使得我们可以以一种统一的方式处理不同的类型，提高代码的可复用性和扩展性。</p><p>希望这样解释可以帮助你理解接口型函数的概念。如有其他问题，请随时提问。</p><p><a href=https://geektutu.com/post/7days-golang-q1.html title="Go 接口型函数的使用场景 | 极客兔兔 (geektutu.com)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Go 接口型函数的使用场景 | 极客兔兔 (geektutu.com)
<i class="fa fa-external-link-alt"></i></a></p><p>在 Go 语言中，有一个常用的技巧可以将其他函数转换为与接口 A 的参数和返回值定义一致的函数类型。这个技巧是利用匿名函数和函数字面量来达到目的。</p><p>下面是一种常见的实现方式：</p><ol><li>定义接口 A，其中包含参数和返回值的定义。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 定义接口 A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>A</span> <span style=color:#66d9ef>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Method</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>创建一个函数类型，其定义与接口 A 的方法签名相同。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 创建与接口 A 签名一致的函数类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>AFunc</span> <span style=color:#66d9ef>func</span>(<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><ol start=3><li>编写一个辅助函数，该函数将接口 A 的方法转换为所需的函数类型。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// 辅助函数，将接口 A 的方法转换为函数类型 AFunc
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>ConvertToAFunc</span>(<span style=color:#a6e22e>a</span> <span style=color:#a6e22e>A</span>) <span style=color:#a6e22e>AFunc</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>i</span> <span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>bool</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>Method</span>(<span style=color:#a6e22e>i</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=4><li>在使用时，可以将实现了接口 A 的类型传入辅助函数 <code>ConvertToAFunc</code> 来得到与接口 A 方法签名一致的函数。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>A</span> = <span style=color:#a6e22e>MyType</span>{} <span style=color:#75715e>// 假设 MyType 实现了接口 A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>aFunc</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ConvertToAFunc</span>(<span style=color:#a6e22e>a</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>result</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>aFunc</span>(<span style=color:#ae81ff>42</span>) <span style=color:#75715e>// 使用转换后的函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>result</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过这种技巧，您可以将其他函数转换为接口 A 的函数类型，从而在需要使用接口 A 的代码中使用这些函数。它为您提供了更大的灵活性，可以轻松地将不同类型的函数适配到接口类型中。</p><h1 id=接口型函数的回调>接口型函数的回调
<a class=header-anchor href=#%e6%8e%a5%e5%8f%a3%e5%9e%8b%e5%87%bd%e6%95%b0%e7%9a%84%e5%9b%9e%e8%b0%83></a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// A Getter loads data for a key.
</span></span><span style=display:flex><span>type Getter interface {
</span></span><span style=display:flex><span>   Get(key string) ([]byte, error)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// A GetterFunc implements Getter with a function.
</span></span><span style=display:flex><span>// 定义函数类型 GetterFunc，并实现 Getter 接口的 Get 方法。
</span></span><span style=display:flex><span>type GetterFunc func(key string) ([]byte, error)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Get implements Getter interface function
</span></span><span style=display:flex><span>// 函数类型实现某一个接口，称之为接口型函数，方便使用者在调用时既能够传入函数作为参数，
</span></span><span style=display:flex><span>// 也能够传入实现了该接口的结构体作为参数。
</span></span><span style=display:flex><span>func (f GetterFunc) Get(key string) ([]byte, error) {
</span></span><span style=display:flex><span>   return f(key)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 测试回调函数是否正常运行
</span></span><span style=display:flex><span>func TestGetter(t *testing.T) {
</span></span><span style=display:flex><span>   //匿名回调函数转换为接口
</span></span><span style=display:flex><span>   var f Getter = GetterFunc(func(key string) ([]byte, error) {
</span></span><span style=display:flex><span>      return []byte(key), nil	//回调函数的返回值
</span></span><span style=display:flex><span>   })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   expect := []byte(&#34;key&#34;)
</span></span><span style=display:flex><span>   //reflect.DeepEqual 用于比较两个值的深度是否相等。它会递归比较两个值及其子值，
</span></span><span style=display:flex><span>   //对于复杂数据结构如数组、切片、映射、结构体等会进行递归比较。
</span></span><span style=display:flex><span>   //调用该接口的方法 f.Get(key string)，实际上就是在调用匿名回调函数。返回[]byte -- key
</span></span><span style=display:flex><span>   //调用f.Get时会调用type Getter interface {
</span></span><span style=display:flex><span>   //Get(key string) ([]byte, error)
</span></span><span style=display:flex><span>   //}的接口函数实现的方法Get调用自身返回传入的Key值
</span></span><span style=display:flex><span>   if v, _ := f.Get(&#34;key&#34;); !reflect.DeepEqual(v, expect) {
</span></span><span style=display:flex><span>      t.Errorf(&#34;callback failed&#34;)
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=reward-container><div><i class="fa-solid fa-mug-hot"></i>请我喝杯咖啡吧 ヾ(^▽^*)))</div><button>
赞赏</button><div class=post-reward><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/ali-pay.png alt="NexT 主题 - 支付宝">
<span>支付宝</span></div><div class=post-reward-item><img src=/imgs/img-lazy-loading.gif data-src=/imgs/wechat-pay.png alt="NexT 主题 - 微信">
<span>微信</span></div></div></div><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right alt=共享知识><ul><li class=post-copyright-title><strong>文章标题：</strong></li><li class=post-copyright-author><strong>本文作者：</strong>
NexT 主题</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=https://wtwtyyds.github.io/post/gee%E5%AD%A6%E4%B9%A0/ title>https://wtwtyyds.github.io/post/gee%E5%AD%A6%E4%B9%A0/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=followme><span>欢迎关注我的其它发布渠道</span><div class=social-list><div class=social-item><a target=_blank class=social-link href=/images/wechat_channel.jpg><span class=icon><i class="fab fa-weixin"></i></span>
<span class=label>WeChat</span></a></div><div class=social-item><a target=_blank class=social-link href=/atom.xml><span class=icon><i class="fa fa-rss"></i></span>
<span class=label>RSS</span></a></div></div></div><div class=post-nav><div class="post-nav-next post-nav-item"></div><div class="post-nav-prev post-nav-item"></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>NexT 主题</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.115.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.5.2 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div><div class=beian><a href=https://beian.miit.gov.cn target=_blank>粤ICP备 18047355-1 号</a>
<img src=/imgs/gongan.png alt=沪公网安备>
<a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=31011402009770" target=_blank>沪公网安备 31011402009770 号</a></div><div class=vendors-list><a target=_blank href=https://vercel.com title=Vercel><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/vercel.svg alt=Vercel></a>
<a target=_blank href=https://upyun.com title=又拍云><img src=/imgs/img-lazy-loading.gif data-src=/imgs/vendors/upyun.png alt=又拍云></a>
<a target=_blank href=https://webify.cloudbase.net title=Webify>Webify</a>
<span>提供CDN/云资源支持</span></div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"copybtn":true,"darkmode":true,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"https://wtwtyyds.github.io/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"找到 ${hits} 个搜索结果","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"limit":1e3,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"postmeta":{"comments":{"enable":true,"plugin":"waline"},"views":{"enable":true,"plugin":"busuanzi"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.5.2","waline":{"cfg":{"emoji":false,"imguploader":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.0fb3547374c917d23a2e5f762b70f3698d20b46a01cc18c38f9c467aeffc99fc.js defer></script></body></html>